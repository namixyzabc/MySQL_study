
### 第1章: SQLとデータベースの基本

まず、SQLを学ぶ上で欠かせないデータベースの基礎知識から始めます。

#### 1-1. データベースとは何か？

データベースとは、**構造化された情報の集まり**を、コンピュータ上で効率的に管理・操作できるようにした仕組みのことです。身近な例では、電話帳や顧客名簿、商品リストなどが挙げられます。

**■エクセルとの違い**

「それならエクセルでも管理できるのでは？」と思うかもしれません。しかし、データベースにはエクセルにはない多くの利点があります。

*   **データの一貫性と整合性**: データベースでは「この列には数値しか入れられない」「このIDは他の行と重複してはならない」といった**ルール（制約）**を設けることができ、データの品質を高く保てます。
*   **大量データの高速処理**: 何百万、何千万件といった大量のデータに対しても、高速に検索や集計を行うことが得意です。
*   **複数人での同時アクセス**: 複数のユーザーが同時に同じデータにアクセスし、更新しても、データが壊れないように制御する仕組み（同時実行制御）があります。
*   **複雑な検索や関連付け**: 複数の表（テーブル）を関連付けて、複雑な条件でデータを抽出することが容易です。

**■リレーショナルデータベース（RDB）**

現在、最も広く使われているのが**リレーショナルデータベース（RDB）**です。RDBでは、データを「テーブル」という二次元の表形式で管理します。

*   **テーブル**: エクセルのシートのようなものです。顧客情報テーブル、商品情報テーブルのように、特定のテーマのデータを格納します。
*   **カラム（列）**: テーブルの縦の列です。「氏名」「年齢」「住所」のように、データの項目を表します。
*   **レコード（行）**: テーブルの横の行です。一人ひとりの顧客データや、一つひとつの商品データのように、具体的なデータの1件分を表します。

RDBの最大の特徴は、これらの**テーブル同士を関連付けられる**点にあります。例えば、「どの顧客がどの商品を買ったか」という情報を、顧客テーブル、商品テーブル、購買履歴テーブルを連携させて管理できます。この「関連（Relation）」が、リレーショナルデータベースという名前の由来です。

#### 1-2. SQLとは何か？

SQL（Structured Query Language、エスキューエルまたはシークェルと読みます）は、この**リレーショナルデータベースと対話するための専門言語**です。SQLを使うことで、私たちはデータベースに対して以下のような命令を出せます。

*   「このテーブルから、特定の条件に合うデータを探してきて」（データ検索）
*   「このテーブルに、新しいデータを追加して」（データ挿入）
*   「このデータの、この部分を書き換えて」（データ更新）
*   「このデータを削除して」（データ削除）
*   「新しいテーブルを作って」（テーブル作成）

SQLは、大きく分けて4つの種類に分類されます。

1.  **DML (Data Manipulation Language): データ操作言語**
    *   テーブル内のデータを操作するための命令群です。
    *   `SELECT`（取得）、`INSERT`（挿入）、`UPDATE`（更新）、`DELETE`（削除）がこれにあたります。最もよく使うSQLです。

2.  **DDL (Data Definition Language): データ定義言語**
    *   データベースの構造（テーブルやインデックスなど）を定義・管理するための命令群です。
    *   `CREATE`（作成）、`ALTER`（変更）、`DROP`（削除）がこれにあたります。

3.  **DCL (Data Control Language): データ制御言語**
    *   データベースへのアクセス権限を管理するための命令群です。
    *   `GRANT`（権限付与）、`REVOKE`（権限剥奪）がこれにあたります。主にデータベース管理者が使用します.

4.  **TCL (Transaction Control Language): トランザクション制御言語**
    *   複数の処理を一つのまとまり（トランザクション）として管理するための命令群です。
    *   `COMMIT`（確定）、`ROLLBACK`（取り消し）がこれにあたります。データの整合性を保つために非常に重要です。

#### 1-3. 環境構築の選択肢

SQLを実際に試すには、データベース管理システム（DBMS）が必要です。DBMSには多くの種類がありますが、代表的なものをいくつか紹介します。

*   **MySQL**: 世界で最も普及しているオープンソースのRDBです。Webアプリケーションのバックエンドで広く使われています。
*   **PostgreSQL**: MySQLと並んで人気の高いオープンソースRDBです。多機能で拡張性が高いのが特徴です。
*   **SQLite**: サーバーを必要とせず、単一のファイルとしてデータベースを扱える軽量なRDBです。スマートフォンアプリや小規模なアプリケーションに組み込まれています。学習用に手軽に始めるのに最適です。
*   **Oracle Database**: 商用データベースの代表格で、大規模な基幹システムなどで高いシェアを誇ります。
*   **SQL Server**: Microsoftが開発したRDBで、Windows環境との親和性が高いです。

**学習のためには、オンラインのSQL実行環境**が便利です。PCに何もインストールすることなく、ブラウザ上ですぐにSQLを試せます。

*   **DB Fiddle**: [https://www.db-fiddle.com/](https://www.db-fiddle.com/)
*   **SQL Fiddle**: [http://sqlfiddle.com/](http://sqlfiddle.com/)

これらのサイトでは、テーブル定義（スキーマ）とSQLクエリを書き込むだけで、すぐに実行結果を確認できます。

#### 1-4. テーブルの構造とキー

RDBの核心的な概念である「キー」について説明します。

**■主キー (Primary Key, PK)**

主キーは、**テーブル内の各レコード（行）を、一意に（重複なく）識別するための特別なカラム**です。主キーに設定されたカラムには、以下のルールが適用されます。

*   **一意性制約**: 同じ値を複数のレコードに設定できません。（例: 社員番号は一人ひとり違う）
*   **NOT NULL制約**: NULL（空っぽの値）を入れることはできません。

主キーは、特定の1行を正確に指定して更新したり削除したりする際に不可欠です。通常、`id`や`employee_id`のような連番の数値が使われることが多いです。

**■外部キー (Foreign Key, FK)**

外部キーは、**別のテーブルの主キーを参照することで、テーブル同士を関連付けるためのカラム**です。

例えば、「社員テーブル」と「部署テーブル」があるとします。

**部署テーブル (`departments`)**

| id (PK) | name |
| :--- | :--- |
| 1 | 営業部 |
| 2 | 開発部 |
| 3 | 人事部 |

**社員テーブル (`employees`)**

| id (PK) | name | department_id (FK) |
| :--- | :--- | :--- |
| 101 | 田中 | 1 |
| 102 | 鈴木 | 2 |
| 103 | 佐藤 | 1 |

このとき、社員テーブルの `department_id` カラムが外部キーです。このカラムには、部署テーブルの `id` カラムに存在する値しか入れることができません。これにより、「田中さんは営業部（ID:1）に所属している」という**テーブル間の関連性**が保証され、存在しない部署（例: ID 99）に社員が所属してしまうといったデータの矛盾を防ぎます。

### 第2章: 【基礎】データの取得 - SELECT文

SQLで最も頻繁に使用するのが、データを取得するための `SELECT` 文です。

#### 2-1. 基本的なSELECT文

テーブルからデータを取得する際の最も基本的な形です。

**構文:**
`SELECT カラム名1, カラム名2, ... FROM テーブル名;`

*   `SELECT`の後には、取得したいカラム名をカンマ区切りで指定します。
*   `FROM`の後には、どのテーブルからデータを取得するかを指定します。
*   文の最後にはセミコロン `;` をつけるのが一般的です（必須でないDBMSもありますが、つける習慣を推奨します）。

**例：`employees`テーブルから社員IDと名前を取得する**

```sql
SELECT id, name FROM employees;
```

**■すべてのカラムを取得する**

`*`（アスタリスク）を使うと、そのテーブルのすべてのカラムを取得できます。

**構文:**
`SELECT * FROM テーブル名;`

**例：`employees`テーブルのすべての情報を取得する**

```sql
SELECT * FROM employees;
```

**注意点**: `SELECT *` は手軽ですが、実務ではパフォーマンスや意図しない仕様変更への影響を考慮し、**必要なカラムだけを明示的に指定することが推奨**されます。

#### 2-2. データの絞り込み - WHERE句

テーブル内の全データではなく、特定の条件に合致するデータだけを取得したい場合に `WHERE` 句を使います。

**構文:**
`SELECT カラム名 FROM テーブル名 WHERE 条件;`

`WHERE` 句では、さまざまな演算子を使って条件を記述します。

**■比較演算子**

| 演算子 | 意味 | 例 |
| :--- | :--- | :--- |
| `=` | 等しい | `WHERE age = 25` (年齢が25歳) |
| `<>` or `!=` | 等しくない | `WHERE department_id <> 1` (部署IDが1ではない) |
| `>` | より大きい | `WHERE salary > 300000` (給料が30万より多い) |
| `<` | より小さい | `WHERE age < 30` (年齢が30歳未満) |
| `>=` | 以上 | `WHERE salary >= 250000` (給料が25万以上) |
| `<=` | 以下 | `WHERE age <= 40` (年齢が40歳以下) |

**例：開発部（部署ID=2）に所属する社員を取得**

```sql
SELECT * FROM employees WHERE department_id = 2;
```

**■論理演算子**

複数の条件を組み合わせる際に使用します。

*   **`AND`**: すべての条件を満たす場合に真（AND条件）
*   **`OR`**: いずれかの条件を満たす場合に真（OR条件）
*   **`NOT`**: 条件を否定する

**例：営業部（ID=1）所属で、かつ、30歳以上の社員**

```sql
SELECT * FROM employees
WHERE department_id = 1 AND age >= 30;
```

**例：開発部（ID=2）または人事部（ID=3）に所属する社員**

```sql
SELECT * FROM employees
WHERE department_id = 2 OR department_id = 3;
```

**■その他の便利な演算子**

*   **`BETWEEN a AND b`**: aからbの範囲内（aとbを含む）
    *   `WHERE age BETWEEN 25 AND 35;` は `WHERE age >= 25 AND age <= 35;` と同じ意味です。

*   **`IN (値1, 値2, ...)`**: カッコ内のいずれかの値と一致する
    *   `WHERE department_id IN (2, 3);` は `WHERE department_id = 2 OR department_id = 3;` と同じ意味です。リストが長い場合に便利です。

*   **`LIKE 'パターン'`**: 文字列の部分一致検索
    *   `%`: 0文字以上の任意の文字列（ワイルドカード）
    *   `_`: 任意の1文字（ワイルドカード）
    *   **例1**: '佐藤'で始まる名前を検索 -> `WHERE name LIKE '佐藤%';`
    *   **例2**: 名前に'木'を含む人を検索 -> `WHERE name LIKE '%木%';`
    *   **例3**: '鈴木 一郎'のように姓と名が3文字の人を検索 -> `WHERE name LIKE '___';`

*   **`IS NULL` / `IS NOT NULL`**: 値がNULL（空）であるか、そうでないかを判定
    *   **重要**: `WHERE column = NULL` とは書けません。必ず `IS NULL` を使います。
    *   **例**: 退職日が設定されていない（NULLの）社員を検索 -> `WHERE retirement_date IS NULL;`

#### 2-3. 結果の並べ替え - ORDER BY句

取得したデータを指定したカラムの順序で並べ替えるには `ORDER BY` 句を使います。

**構文:**
`SELECT カラム名 FROM テーブル名 [WHERE 条件] ORDER BY 並べ替えたいカラム [ASC|DESC];`

*   **`ASC`**: 昇順（Ascending）。小さい方から大きい方へ（A→Z、1→10）。デフォルトなので省略可能です。
*   **`DESC`**: 降順（Descending）。大きい方から小さい方へ（Z→A、10→1）。

**例：社員を年齢の若い順（昇順）に並べる**

```sql
SELECT * FROM employees ORDER BY age ASC;
-- ASCは省略可能
SELECT * FROM employees ORDER BY age;
```

**例：社員を入社日の新しい順（降順）に並べる**

```sql
SELECT * FROM employees ORDER BY hire_date DESC;
```

**■複数キーでのソート**

カンマで区切ることで、複数のカラムを基準に並べ替えができます。先に指定したカラムが優先されます。

**例：部署IDの昇順で並べ、同じ部署内では給料の高い順（降順）に並べる**

```sql
SELECT id, name, department_id, salary
FROM employees
ORDER BY department_id ASC, salary DESC;
```

#### 2-4. 結果の件数制限 - LIMIT句

取得するレコード（行）の件数を制限したい場合に `LIMIT` 句を使います。大量のデータから一部だけを確認したい場合や、ランキングの上位N件を取得したい場合に便利です。

**構文:**
`SELECT カラム名 FROM テーブル名 [ORDER BY ...] LIMIT 件数;`

**例：給料が高い上位3名の社員を取得**

```sql
SELECT id, name, salary
FROM employees
ORDER BY salary DESC
LIMIT 3;
```

**■オフセットの指定 (OFFSET)**

`OFFSET` を使うと、指定した件数分をスキップしてからデータを取得できます。これはWebサイトのページネーション（「2ページ目を表示」など）を実装する際によく使われます。

**構文:**
`... LIMIT 件数 OFFSET スキップする件数;`

**例：給料ランキングの4位から6位の3名を取得（3件スキップして3件取得）**

```sql
SELECT id, name, salary
FROM employees
ORDER BY salary DESC
LIMIT 3 OFFSET 3;
```

**注意**: `LIMIT` はMySQLやPostgreSQL、SQLiteで使われる方言です。SQL Serverでは `TOP N`、Oracleや標準SQLでは `FETCH FIRST N ROWS ONLY` を使います。

#### 2-5. 重複の排除 - DISTINCT

`SELECT` の結果から、重複する行を排除してユニークな値だけを取得したい場合に `DISTINCT` を使います。

**構文:**
`SELECT DISTINCT カラム名 FROM テーブル名;`

**例：社員が所属している部署IDの一覧を取得する（重複なし）**

`employees` テーブルには同じ部署IDの社員が複数いるため、普通にSELECTすると重複します。

```sql
-- 通常のSELECT（重複あり）
SELECT department_id FROM employees;
-- 結果例: 1, 2, 1, 3, 2

-- DISTINCTを使った場合（重複なし）
SELECT DISTINCT department_id FROM employees;
-- 結果: 1, 2, 3
```

`DISTINCT` は複数のカラムに対しても適用できます。その場合、指定されたカラムの組み合わせが完全に一致する行が重複とみなされます。

#### 2-6. 別名の設定 - AS

カラム名やテーブル名に、一時的な別名（エイリアス）を付けることができます。`AS` キーワードを使いますが、省略することも可能です。

**別名を使うメリット:**

*   **結果の可読性向上**: `employee_id` を「社員番号」のように日本語にしたり、分かりやすい名前に変えられます。
*   **関数の結果に名前を付ける**: 後述する集計関数の結果のカラムに名前を付けられます。
*   **テーブル名の短縮**: 長いテーブル名を短くして、クエリを簡潔に書けます（特にJOINで有効）。

**構文:**
`SELECT カラム名 AS 別名 FROM テーブル名 AS 別名;`

**例：カラム名に別名を付ける**

```sql
SELECT
  id AS "社員ID",
  name AS "氏名",
  salary AS "月給"
FROM
  employees;
```
（`AS`は省略可能です: `SELECT id "社員ID", ...`）

### 第3章: 【基礎】データの操作 - DML (INSERT, UPDATE, DELETE)

データの取得（SELECT）と並んで重要なのが、データを追加、更新、削除するDMLです。**これらの操作はテーブルデータを直接変更するため、実行には十分な注意が必要**です。

#### 3-1. データの追加 - INSERT文

テーブルに新しいレコード（行）を追加するには `INSERT` 文を使います。

**構文1：カラムを指定して追加**

`INSERT INTO テーブル名 (カラム1, カラム2, ...) VALUES (値1, 値2, ...);`

この形式が最も安全で推奨されます。値を挿入するカラムを明示的に指定するため、テーブルのカラム順序が変わっても影響を受けません。

**例：`employees`テーブルに新しい社員を追加する**

```sql
INSERT INTO employees (id, name, age, department_id, salary, hire_date)
VALUES (104, '山田 太郎', 28, 2, 320000, '2023-04-01');
```

**構文2：すべてのカラムに追加（カラム指定を省略）**

`INSERT INTO テーブル名 VALUES (値1, 値2, ...);`

この場合、`VALUES`句の値は、テーブル定義のカラム順序と完全に一致している必要があります。

**例：`employees`テーブルに新しい社員を追加する（カラム省略）**

```sql
INSERT INTO employees
VALUES (105, '高橋 花子', 35, 1, 400000, '2021-10-01', NULL);
-- 最後のNULLは退職日(retirement_date)カラムに対応
```

**注意**: カラムを省略する形式は、将来テーブルの列順が変更された場合にエラーの原因となるため、**カラムを明示的に指定する構文1の使用を強く推奨**します。

**■複数行の挿入**

一度に複数のレコードを挿入することもできます。`VALUES`句をカンマで繋げます。

```sql
INSERT INTO employees (id, name, age, department_id) VALUES
(106, '伊藤 次郎', 22, 1),
(107, '渡辺 三郎', 41, 3),
(108, '山本 四郎', 33, 2);
```

#### 3-2. データの更新 - UPDATE文

既存のレコードの値を変更するには `UPDATE` 文を使います。

**構文:**
`UPDATE テーブル名 SET カラム1 = 新しい値1, カラム2 = 新しい値2, ... WHERE 条件;`

**★★最重要注意点★★**
`UPDATE`文で **`WHERE`句を書き忘れると、テーブルの全レコードが更新されてしまいます**。これは非常に危険な操作であり、データ破壊に繋がります。`UPDATE`を実行する前には、必ず`WHERE`句を確認し、意図したレコードだけが対象になっているかを確認する癖をつけましょう。

**例：社員IDが103の佐藤さんの給料を350000に更新する**

```sql
UPDATE employees
SET salary = 350000
WHERE id = 103;
```

**例：営業部（ID=1）の全社員の給料を一律10000円昇給させる**

```sql
UPDATE employees
SET salary = salary + 10000
WHERE department_id = 1;
```

`SET`句では、このように既存の値を使った計算も可能です。

#### 3-3. データの削除 - DELETE文

レコードを削除するには `DELETE` 文を使います。

**構文:**
`DELETE FROM テーブル名 WHERE 条件;`

**★★最重要注意点★★**
`DELETE`文も`UPDATE`文と同様に、 **`WHERE`句を書き忘れると、テーブルの全レコードが削除されてしまいます**。これも取り返しのつかない事態に繋がりかねないため、実行前の`WHERE`句の確認は必須です。

**例：社員IDが108の社員のデータを削除する**

```sql
DELETE FROM employees
WHERE id = 108;
```

**例：退職済みの社員（retirement_dateがNULLでない）を全員削除する**

```sql
DELETE FROM employees
WHERE retirement_date IS NOT NULL;
```

**■TRUNCATE TABLEとの違い**

テーブルの全データを削除する方法として `TRUNCATE TABLE` 文もあります。

`TRUNCATE TABLE テーブル名;`

`DELETE FROM テーブル名;`（WHERE句なし）と `TRUNCATE TABLE` は、どちらも全件削除しますが、内部的な動作が異なります。

| 項目 | `DELETE` | `TRUNCATE` |
| :--- | :--- | :--- |
| 分類 | DML | DDL |
| 処理速度 | 遅い（1行ずつ削除） | 速い（テーブルごと再作成） |
| `WHERE`句 | 使用可能 | 使用不可 |
| ロールバック | 可能 | 不可（DBMSによる） |
| トリガー | 実行される | 実行されない |

簡単に言うと、**`TRUNCATE` は高速だが大雑把な全削除**、**`DELETE` は低速だが丁寧な行単位の削除**です。特定の条件で削除したい場合は`DELETE`、テーブルを空にしたいだけなら`TRUNCATE`が適しています。

### 第4章: 【基礎】テーブルの定義 - DDL

DDLは、テーブルそのものを作成したり、構造を変更したり、削除したりするためのSQLです。

#### 4-1. テーブルの作成 - CREATE TABLE文

新しいテーブルを作成するには `CREATE TABLE` 文を使います。テーブル名と、各カラムの名前、そして**データ型**を指定する必要があります。

**構文:**
```sql
CREATE TABLE テーブル名 (
    カラム名1 データ型 [制約],
    カラム名2 データ型 [制約],
    ...
    [テーブルレベルの制約]
);
```

**■主要なデータ型**

どのDBMSでも共通して使われる代表的なデータ型です。

| データ型 | 説明 | 例 |
| :--- | :--- | :--- |
| `INTEGER` / `INT` | 整数 | `100`, `-50` |
| `DECIMAL(p, s)` / `NUMERIC(p, s)` | 固定小数点数（正確な数値）。pは全体の桁数、sは小数点以下の桁数。 | `DECIMAL(10, 2)` -> `12345678.99` |
| `VARCHAR(n)` | 可変長の文字列。nは最大文字数。 | `VARCHAR(255)` -> "こんにちは" |
| `CHAR(n)` | 固定長の文字列。nは文字数。指定文字数に満たない場合は空白で埋められる。 | `CHAR(8)` -> "abc" は "abc " として保存 |
| `TEXT` | 長い文字列 | `TEXT` |
| `DATE` | 日付 (YYYY-MM-DD) | `'2024-01-20'` |
| `TIME` | 時刻 (HH:MI:SS) | `'12:30:45'` |
| `TIMESTAMP` / `DATETIME` | 日付と時刻 | `'2024-01-20 12:30:45'` |
| `BOOLEAN` / `BOOL` | 真偽値 (true/false) | `true` |

**■制約 (Constraints)**

データにルールを課し、不正なデータが入るのを防ぐための設定です。

*   **`NOT NULL`**: NULL値を許可しない。必ず何かしらの値を入れる必要があります。
*   **`UNIQUE`**: カラム内で値の重複を許可しない。
*   **`PRIMARY KEY`**: 主キー制約。`NOT NULL`と`UNIQUE`を兼ね備えています。1つのテーブルに1つだけ設定できます。
*   **`FOREIGN KEY`**: 外部キー制約。他のテーブルの主キーを参照します。
*   **`CHECK`**: カラムに入る値が特定の条件を満たすかチェックします。（例: `CHECK (age >= 0)`）
*   **`DEFAULT 値`**: データ挿入時に値が指定されなかった場合に、自動的に設定されるデフォルト値。

**例：`products`（商品）テーブルを作成する**

```sql
CREATE TABLE products (
    id INTEGER PRIMARY KEY, -- 商品ID（主キー）
    name VARCHAR(100) NOT NULL, -- 商品名（必須）
    code VARCHAR(20) NOT NULL UNIQUE, -- 商品コード（必須、重複不可）
    price INTEGER NOT NULL CHECK (price >= 0), -- 価格（必須、0以上）
    description TEXT, -- 商品説明
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- 登録日時（デフォルトで現在時刻）
);
```

#### 4-2. テーブル構造の変更 - ALTER TABLE文

既存のテーブルの構造（カラムの追加・変更・削除など）を変更するには `ALTER TABLE` 文を使います。

**■カラムの追加 (`ADD COLUMN`)**

```sql
ALTER TABLE employees ADD COLUMN phone_number VARCHAR(20);
```
これで `employees` テーブルに `phone_number` カラムが追加されます。

**■カラムの削除 (`DROP COLUMN`)**

```sql
ALTER TABLE employees DROP COLUMN phone_number;
```

**■カラムの定義変更 (`MODIFY COLUMN` / `ALTER COLUMN`)**

データ型や制約を変更します。この構文はDBMSによる方言が強い部分です。

*   **MySQLの場合 (`MODIFY`)**
    ```sql
    ALTER TABLE employees MODIFY COLUMN name VARCHAR(100) NOT NULL;
    ```
*   **PostgreSQLの場合 (`ALTER COLUMN`)**
    ```sql
    ALTER TABLE employees ALTER COLUMN name TYPE VARCHAR(100);
    ALTER TABLE employees ALTER COLUMN name SET NOT NULL;
    ```

#### 4-3. テーブルの削除 - DROP TABLE文

テーブルをデータベースから完全に削除するには `DROP TABLE` 文を使います。

**構文:**
`DROP TABLE テーブル名;`

**例：`products`テーブルを削除する**

```sql
DROP TABLE products;
```

**注意**: `DROP TABLE` はテーブルの構造とデータすべてを削除し、**元に戻すことはできません**。非常に強力で危険なコマンドなので、実行は慎重に行う必要があります。

### 第5章: 【中級】集計とグループ化

個々のデータを見るだけでなく、データを集計して合計や平均を求めたり、グループに分けて分析したりすることは、データ分析の基本です。

#### 5-1. 集計関数 (Aggregate Functions)

集計関数は、複数の行の値から一つの集計結果（スカラー値）を返します。`SELECT`句や後述する`HAVING`句で使われます。

*   **`COUNT(カラム名 or *)`**: 行数を数える。
    *   `COUNT(*)`: 全ての行数を数える。
    *   `COUNT(カラム名)`: そのカラムに `NULL` でない値が入っている行数を数える。
*   **`SUM(カラム名)`**: 数値カラムの合計値を計算する。
*   **`AVG(カラム名)`**: 数値カラムの平均値を計算する。
*   **`MAX(カラム名)`**: カラムの最大値を取得する。
*   **`MIN(カラム名)`**: カラムの最小値を取得する。

**例：社員の総数、給料の合計、平均給料を計算する**

```sql
SELECT
    COUNT(*) AS total_employees,
    SUM(salary) AS total_salary,
    AVG(salary) AS average_salary,
    MAX(salary) AS max_salary,
    MIN(salary) AS min_salary
FROM
    employees;
```
このクエリは、テーブル全体に対して1行の結果を返します。

#### 5-2. データのグループ化 - GROUP BY句

`GROUP BY`句を使うと、**特定のカラムの値が同じレコードをグループにまとめ、そのグループごとに集計関数を適用**できます。

**構文:**
`SELECT カラム名, 集計関数(...) FROM テーブル名 GROUP BY カラム名;`

**重要なルール**: `GROUP BY` を使った場合、`SELECT`句に書けるのは以下のものだけです。
1.  `GROUP BY` で指定したカラム
2.  集計関数 (`COUNT`, `SUM`など)

**例：部署ごとに、所属人数、平均給料、最高給料を計算する**

```sql
SELECT
    department_id,
    COUNT(*) AS num_employees,
    AVG(salary) AS avg_salary,
    MAX(salary) AS max_salary
FROM
    employees
GROUP BY
    department_id;
```

このクエリの実行プロセスは以下のようになります。
1. `FROM employees`: `employees`テーブルからデータを取得します。
2. `GROUP BY department_id`: `department_id`が同じ行をグループにまとめます（営業部グループ、開発部グループなど）。
3. `SELECT ...`: 各グループに対して `SELECT`句の計算（`COUNT`, `AVG`, `MAX`）を行い、結果を生成します。

結果は以下のようになります（部署IDごとに1行の結果）。

| department_id | num_employees | avg_salary | max_salary |
| :--- | :--- | :--- | :--- |
| 1 | 50 | 380000 | 700000 |
| 2 | 30 | 450000 | 800000 |
| 3 | 15 | 350000 | 550000 |

#### 5-3. グループ化した結果の絞り込み - HAVING句

`GROUP BY`でグループ化した結果に対して、さらに条件を指定して絞り込みたい場合があります。その際に使うのが `HAVING` 句です。

**`WHERE`句と`HAVING`句の違い**

これは非常に重要なポイントです。

*   **`WHERE`句**: **グループ化する前**の、個々のレコードに対して条件を適用します。
*   **`HAVING`句**: **グループ化した後**の、集計結果に対して条件を適用します。`HAVING`句では集計関数を使うことができます。

**SQLの実行順序（概念）**
`FROM` → `WHERE` → `GROUP BY` → `HAVING` → `SELECT` → `ORDER BY`
この順序を覚えておくと、`WHERE`と`HAVING`の役割の違いが理解しやすくなります。

**構文:**
`SELECT ... FROM ... WHERE ... GROUP BY ... HAVING 条件;`

**例：所属人数が20人以上の部署について、その部署IDと人数、平均給料を求める**

この「所属人数が20人以上」という条件は、グループ化した後の集計結果（`COUNT(*)`）に対する条件なので、`HAVING`句を使います。

```sql
SELECT
    department_id,
    COUNT(*) AS num_employees,
    AVG(salary) AS avg_salary
FROM
    employees
GROUP BY
    department_id
HAVING
    COUNT(*) >= 20; -- グループ化した結果の行数が20以上のものに絞る
```

**例：30歳以上の社員のみを対象とし、部署ごとの平均給料を計算。そのうち、平均給料が40万円以上の部署のみ表示する。**

*   「30歳以上の社員」は、グループ化前の個々のレコードに対する条件 → `WHERE`句
*   「平均給料が40万円以上」は、グループ化後の集計結果に対する条件 → `HAVING`句

```sql
SELECT
    department_id,
    AVG(salary) AS avg_salary
FROM
    employees
WHERE
    age >= 30 -- 1. まず30歳以上の社員に絞る
GROUP BY
    department_id -- 2. 部署ごとにグループ化
HAVING
    AVG(salary) >= 400000; -- 3. グループの平均給料が40万以上のものに絞る
```

### 第6章: 【中級】複数テーブルの結合 - JOIN

リレーショナルデータベースの真価は、複数のテーブルを連携させてデータを扱うことにあります。そのために不可欠なのが `JOIN` です。JOINを使うことで、正規化（データを適切に分割して管理すること）されたテーブルから、必要な情報を組み合わせて取得できます。

#### 6-1. なぜJOINが必要か？

もし社員情報と部署情報を一つの巨大なテーブルで管理したらどうなるでしょうか。

| 社員ID | 社員名 | 部署名 | 部署所在地 |
| :--- | :--- | :--- | :--- |
| 101 | 田中 | 営業部 | 東京 |
| 102 | 鈴木 | 開発部 | 大阪 |
| 103 | 佐藤 | 営業部 | 東京 |

この形式には問題があります。
*   **データの重複**: 「営業部」「東京」といった情報が、営業部の社員の数だけ重複して保存され、無駄が多いです。
*   **更新の困難さ**: 営業部の所在地が「横浜」に変わった場合、営業部に所属する全社員のレコードを更新する必要があり、手間がかかり更新漏れのリスクもあります。

そこで、データを「社員テーブル」と「部署テーブル」に分割します（**正規化**）。

**`employees`テーブル**
| id | name | department_id (FK) |
| :--- | :--- | :--- |
| 101 | 田中 | 1 |
| 102 | 鈴木 | 2 |
| 103 | 佐藤 | 1 |

**`departments`テーブル**
| id (PK) | name | location |
| :--- | :--- | :--- |
| 1 | 営業部 | 東京 |
| 2 | 開発部 | 大阪 |

この分割された状態から、「社員名と、その社員が所属する部署名」を取得したいときに `JOIN` を使います。

#### 6-2. 内部結合 - INNER JOIN

`INNER JOIN`は、最も基本的でよく使われる結合です。**両方のテーブルに、結合条件に一致するレコードが存在する場合にのみ**、それらを結合して結果を返します。

**構文:**
```sql
SELECT カラム名...
FROM テーブル1
INNER JOIN テーブル2 ON 結合条件;
```
`ON`句で、どのカラムをキーにしてテーブルを繋ぐかを指定します。通常は「テーブル1の外部キー = テーブル2の主キー」という形になります。`INNER`は省略可能です。

**例：社員名と所属部署名を取得する**

```sql
SELECT
    e.name AS employee_name, -- eはemployeesの別名
    d.name AS department_name -- dはdepartmentsの別名
FROM
    employees AS e -- テーブルに別名を付けるとクエリが簡潔になる
INNER JOIN
    departments AS d ON e.department_id = d.id;
```
このクエリは、`employees`テーブルの`department_id`と`departments`テーブルの`id`が一致する行同士を結合します。部署に所属していない社員や、社員が一人もいない部署は結果に含まれません。



#### 6-3. 外部結合 - LEFT JOIN (LEFT OUTER JOIN)

`LEFT JOIN`は、`INNER JOIN`とは異なり、**左側のテーブル（FROM句で先に指定したテーブル）のレコードはすべて結果に含めます**。そして、結合条件に一致する右側のテーブルのレコードを結合します。もし右側に一致するレコードがない場合は、右側テーブルのカラムには`NULL`が入ります。`OUTER`は省略可能です。

**構文:**
```sql
SELECT カラム名...
FROM テーブル1 -- 左テーブル
LEFT JOIN テーブル2 -- 右テーブル
ON 結合条件;
```

**利用シーン**:
*   主となるテーブルのデータはすべて表示しつつ、関連する情報を付け加えたい場合。
*   「所属部署が決まっていない社員」のように、片方のテーブルにしか存在しないデータを探したい場合。

**例：すべての社員と、もし所属していればその部署名を取得する**

仮に`department_id`が`NULL`の社員（部署未所属）がいるとします。

```sql
SELECT
    e.name AS employee_name,
    d.name AS department_name
FROM
    employees AS e
LEFT JOIN
    departments AS d ON e.department_id = d.id;
```

この結果、部署未所属の社員の`department_name`は`NULL`として表示されます。`INNER JOIN`ではこの社員は結果に含まれません。

**例：部署に所属していない社員をリストアップする**

`LEFT JOIN`の結果、右側のテーブルのカラムが`NULL`になる行を探します。

```sql
SELECT
    e.name
FROM
    employees AS e
LEFT JOIN
    departments AS d ON e.department_id = d.id
WHERE
    d.id IS NULL; -- 部署情報が結合できなかった（=部署IDがNULL）社員
```


#### 6-4. 外部結合 - RIGHT JOIN (RIGHT OUTER JOIN)

`RIGHT JOIN`は`LEFT JOIN`の逆です。**右側のテーブル（JOIN句で指定したテーブル）のレコードをすべて**結果に含めます。左側に一致するレコードがない場合は、左側テーブルのカラムに`NULL`が入ります。

**構文:**
```sql
SELECT カラム名...
FROM テーブル1 -- 左テーブル
RIGHT JOIN テーブル2 -- 右テーブル
ON 結合条件;
```

**例：すべての部署と、もし所属していればその社員名を取得する**

```sql
SELECT
    e.name AS employee_name,
    d.name AS department_name
FROM
    employees AS e
RIGHT JOIN
    departments AS d ON e.department_id = d.id;
```
この結果、社員が一人も所属していない部署もリストアップされ、その`employee_name`は`NULL`になります。

**実務上のヒント**: `RIGHT JOIN`は、テーブルの順序を入れ替えて`LEFT JOIN`で書くことができるため、可読性の観点から`LEFT JOIN`に統一して書くことが好まれる傾向にあります。

#### 6-5. 完全外部結合 - FULL OUTER JOIN

`FULL OUTER JOIN`は、**両方のテーブルのすべてのレコード**を結果に含めます。片方のテーブルにしか存在しないデータについては、もう片方のテーブルのカラムが`NULL`になります。`LEFT JOIN`と`RIGHT JOIN`を合わせたような動作です。

**構文:**
```sql
SELECT カラム名...
FROM テーブル1
FULL OUTER JOIN テーブル2 ON 結合条件;
```

利用シーンは限定的ですが、両方のテーブルのデータを網羅的に比較したい場合などに使われます。
（MySQLは`FULL OUTER JOIN`を直接サポートしていませんが、`LEFT JOIN`と`RIGHT JOIN`を`UNION`で組み合わせることで実現できます。）

#### 6-6. 自己結合 - SELF JOIN

`SELF JOIN`は、**同じテーブルを2つあるものと見なして、それ自体に結合する**テクニックです。テーブルに別名（エイリアス）を付けることが必須となります。

**利用シーン**:
*   階層構造を持つデータを扱う場合。例えば、社員テーブルに「上司の社員ID」というカラムがあるとき、部下の名前と上司の名前を一覧表示したい場合。

**例：社員とその上司の名前を一覧表示する**

`employees`テーブルに`manager_id`（上司の社員ID）カラムがあるとします。

```sql
-- employeesテーブルの構造
-- id, name, manager_id
-- 101, 田中, 102
-- 102, 鈴木, NULL  (鈴木さんは上司なし)
-- 103, 佐藤, 102

SELECT
    e.name AS employee_name, -- 部下 (employee)
    m.name AS manager_name   -- 上司 (manager)
FROM
    employees AS e -- 部下用のテーブルとして「e」と名付ける
LEFT JOIN -- 上司がいない社員も表示したいためLEFT JOIN
    employees AS m ON e.manager_id = m.id; -- 上司用のテーブルとして「m」と名付ける
```
このクエリでは、`employees`テーブルを「部下(e)」と「上司(m)」という2つの役割で扱っています。`e.manager_id`（部下の上司ID）と`m.id`（上司の社員ID）を結合キーにすることで、部下の名前と上司の名前を1行に表示できます。

### 第7章: 【中級】サブクエリ（副問い合わせ）

サブクエリは、**SQL文の中に入れ子になった `SELECT` 文**のことです。サブクエリを使うことで、一度のクエリでより複雑なデータ取得が可能になります。クエリを部品のように分割して考えられるため、複雑な処理を段階的に記述できます。

#### 7-1. サブクエリとは？

サブクエリは`()`で囲んで記述され、外側のメインクエリが実行される前に実行されます。サブクエリの結果は、メインクエリから「使い捨てのテーブル」や「単一の値」のように扱われます。

#### 7-2. サブクエリが使える場所

サブクエリはSQL文の様々な場所で利用できます。

*   **`WHERE`句**: 最も一般的な使い方。条件式の右辺にサブクエリの結果を使います。
*   **`FROM`句**: サブクエリの結果を一つのテーブルと見なして扱います。これを**インラインビュー**と呼びます。
*   **`SELECT`句**: サブクエリが単一の値を返す場合に使えます。これを**スカラサブクエリ**と呼びます。

#### 7-3. `WHERE`句でのサブクエリ

**■単一行サブクエリ**

サブクエリが必ず1行1列の結果を返す場合、`=`, `>`, `<` などの比較演算子でメインクエリと繋ぐことができます。

**例：平均給料よりも高い給料をもらっている社員をすべて取得する**

1.  まず、平均給料を計算するサブクエリを考えます: `(SELECT AVG(salary) FROM employees)`
2.  次に、その結果を使って社員を絞り込むメインクエリを書きます。

```sql
SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

**■複数行サブクエリ**

サブクエリが複数行の結果を返す可能性がある場合、`IN`, `ANY`, `ALL` といった演算子を使います。

*   **`IN`**: サブクエリの結果の**いずれかと一致**すれば真。
    *   `WHERE column IN (サブクエリ)` は「サブクエリの結果リストに含まれる値」を探します。

*   **`ANY`**: サブクエリの結果の**いずれか**と比較して条件を満たせば真。
    *   `> ANY (サブクエリ)` は「サブクエリ結果の最小値より大きい」という意味になります。

*   **`ALL`**: サブクエリの結果の**すべて**と比較して条件を満たせば真。
    *   `> ALL (サブクエリ)` は「サブクエリ結果の最大値より大きい」という意味になります。

**例（IN）：東京に所在地がある部署に所属する全社員を取得する**

1.  東京にある部署IDをサブクエリで取得します: `(SELECT id FROM departments WHERE location = '東京')`
2.  その部署IDリストを使って社員を絞り込みます。

```sql
SELECT name, department_id
FROM employees
WHERE department_id IN (SELECT id FROM departments WHERE location = '東京');
```
これは`JOIN`でも書けますが、サブクエリを使うと「まず部署IDリストを取得し、次にそのリストで社員を探す」という思考の流れに沿って書きやすいメリットがあります。

#### 7-4. `FROM`句でのサブクエリ（インラインビュー）

`FROM`句にサブクエリを置くと、そのサブクエリの実行結果が一時的な仮想テーブル（インラインビュー）として扱われます。この仮想テーブルに別名を付けて、メインクエリで利用します。

**例：部署ごとに計算した平均給料を、さらに年代別に集計する**

これは一度の`GROUP BY`では困難です。そこで、まず「部署ごとの情報（ID, 名前, 平均給料）」をインラインビューとして作成し、それと社員テーブルをJOINします。

```sql
SELECT
    d_summary.department_name,
    AVG(e.age) AS avg_age,
    d_summary.avg_salary -- インラインビューのカラムを参照
FROM
    employees AS e
INNER JOIN
    -- ここからがインラインビュー
    (
        SELECT
            id,
            name AS department_name,
            AVG(salary) AS avg_salary
        FROM
            departments d
        JOIN
            employees e ON d.id = e.department_id
        GROUP BY
            d.id, d.name
    ) AS d_summary -- インラインビューにd_summaryという別名を付ける
    ON e.department_id = d_summary.id
GROUP BY
    d_summary.department_name, d_summary.avg_salary;
```

#### 7-5. 相関サブクエリ

これまでのサブクエリは、単独で実行可能で、外側のクエリとは独立していました。一方、**相関サブクエリ**は、**内側のサブクエリが、外側のクエリのカラムを参照する**という特徴があります。

そのため、相関サブクエリは外側のクエリの各行に対して一度ずつ、繰り返し実行されるイメージになります。処理が重くなりがちなので注意が必要です。

**例：各部署において、その部署の平均給料よりも高い給料をもらっている社員をリストアップする**

この場合、「部署の平均給料」は、外側のクエリで処理中の社員が所属する部署によって変わります。

```sql
SELECT
    e1.name,
    e1.salary,
    e1.department_id
FROM
    employees AS e1 -- 外側のクエリのテーブル
WHERE
    e1.salary > (
        -- ここから相関サブリクエリ
        SELECT AVG(e2.salary)
        FROM employees AS e2
        WHERE e2.department_id = e1.department_id -- 外側のe1のdepartment_idを参照している
    );
```
このサブクエリは、`e1`の行が1つ処理されるたびに、「`e1`と同じ部署IDを持つ社員の平均給料」を計算し、`e1`の給料と比較します。

**■`EXISTS`演算子**

相関サブクエリと共によく使われるのが`EXISTS`です。`EXISTS`は、サブクエリが**1行でも結果を返せば真(True)**、1行も返さなければ偽(False)を返します。サブクリの結果の値自体は気にせず、存在するかどうかだけをチェックします。

**例：一度でも商品を購入したことがある顧客のリストを取得する**

```sql
SELECT
    c.id,
    c.name
FROM
    customers AS c
WHERE
    EXISTS (
        -- この顧客IDの購買履歴がsalesテーブルに存在するかチェック
        SELECT 1 -- SELECT句は何でもよい（慣習的に1や*が使われる）
        FROM sales AS s
        WHERE s.customer_id = c.id -- 外側の顧客IDを参照
    );
```
このクエリは、`customers`テーブルの各顧客`c`に対して、「`sales`テーブルに`c.id`と一致する購買記録があるか？」をサブクエリでチェックし、存在すればその顧客を結果に含めます。

### 第8章: 【応用】発展的なSQL機能

ここからは、SQLをより強力かつエレガントに記述するための応用的な機能を紹介します。これらを使いこなせると、複雑なデータ分析や集計が格段に楽になります。

#### 8-1. ウィンドウ関数 (Window Functions)

ウィンドウ関数は、`GROUP BY`のように行を集約するのではなく、**元の行を残したまま、行の集合（ウィンドウ）に対して計算を行う**ことができる非常に強力な機能です。`OVER()`句と一緒に使います。

**`GROUP BY`との違い**:
*   `GROUP BY`: 元の行をグループに集約してしまい、個々の行の情報は失われる。
*   ウィンドウ関数: 元の行はすべて保持し、各行に計算結果（ランキングや移動平均など）を新しいカラムとして追加する。

**構文:**
`関数名() OVER ( [PARTITION BY カラム] [ORDER BY カラム] )`

*   `PARTITION BY`: ウィンドウをどのグループに分割するか指定します。`GROUP BY`に似ていますが、行を集約しません。
*   `ORDER BY`: ウィンドウ内でどの順序で計算を行うか指定します。

**■ランキング関数**

*   `ROW_NUMBER()`: パーティション内で、一意の連番を振る。（1, 2, 3, 4, ...）
*   `RANK()`: 順位を付ける。同順位がある場合、次の順位は飛ばされる。（1, 2, 2, 4, ...）
*   `DENSE_RANK()`: 順位を付ける。同順位があっても、次の順位は飛ばされない。（1, 2, 2, 3, ...）

**例：部署ごとに、給料の高い順にランキングを付ける**

```sql
SELECT
    name,
    department_id,
    salary,
    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS dept_rank,
    DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS dept_dense_rank,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS dept_row_num
FROM
    employees;
```
このクエリは、`department_id`でグループ（パーティション）を作り、その中で`salary`の降順に並べ、各行にランキングを付与します。元の行はすべて結果に残ります。

**■集計関数をウィンドウ関数として使う**

`SUM`, `AVG`, `COUNT`などの集計関数も`OVER()`句と組み合わせることでウィンドウ関数として使えます。

**例：各社員の給料と、その社員が所属する部署の平均給料を一覧表示する**

相関サブクエリでも可能でしたが、ウィンドウ関数を使うとよりシンプルに書けます。

```sql
SELECT
    name,
    salary,
    department_id,
    -- 部署ごと(PARTITION BY)の平均給料を計算
    AVG(salary) OVER (PARTITION BY department_id) AS avg_salary_in_dept
FROM
    employees;
```

**例：累積合計（売上の累計など）を計算する**

`ORDER BY`と組み合わせることで、累積計算が可能です。

```sql
SELECT
    order_date,
    daily_sales,
    -- 日付順に売上を累積していく
    SUM(daily_sales) OVER (ORDER BY order_date) AS cumulative_sales
FROM
    sales_summary;
```

#### 8-2. CASE式

`CASE`式は、SQL内で**条件分岐**を実現するための構文です。`IF-THEN-ELSE`のような処理を`SELECT`句や`WHERE`句、`ORDER BY`句など、様々な場所で記述できます。

**構文1：単純CASE式**

```sql
CASE 評価するカラム
    WHEN 値1 THEN 結果1
    WHEN 値2 THEN 結果2
    ...
    ELSE デフォルトの結果
END
```

**例：部署IDを部署名に変換する**

```sql
SELECT
    name,
    CASE department_id
        WHEN 1 THEN '営業部'
        WHEN 2 THEN '開発部'
        WHEN 3 THEN '人事部'
        ELSE '所属不明'
    END AS department_name
FROM
    employees;
```

**構文2：検索CASE式**

より複雑な条件を記述できます。

```sql
CASE
    WHEN 条件1 THEN 結果1
    WHEN 条件2 THEN 結果2
    ...
    ELSE デフォルトの結果
END
```

**例：年齢層ごとにラベリングする**

```sql
SELECT
    name,
    age,
    CASE
        WHEN age < 30 THEN '若手'
        WHEN age >= 30 AND age < 50 THEN '中堅'
        WHEN age >= 50 THEN 'ベテラン'
        ELSE '不明'
    END AS age_group
FROM
    employees;
```

`CASE`式は、データの変換やカテゴリ分け、複雑な条件でのソートなど、非常に用途が広く強力なツールです。

#### 8-3. 集合演算子

集合演算子は、2つ以上の`SELECT`文の結果セットを、数学の集合のように結合したり、差分を取ったりするための演算子です。

**注意点**: 集合演算子で結ばれる`SELECT`文は、**カラムの数、順序、そして対応するデータ型が一致**している必要があります。

*   **`UNION`**: 和集合。2つの結果を結合し、**重複する行は取り除きます**。
*   **`UNION ALL`**: 和集合。2つの結果を結合し、**重複する行もすべて含めます**。重複排除の処理がない分、`UNION`よりも高速です。
*   **`INTERSECT`**: 積集合。両方の結果に**共通して存在する行のみ**を返します。
*   **`EXCEPT` (または `MINUS`)**: 差集合。1つ目の結果から、2つ目の結果に存在する行を**取り除いたもの**を返します。

**例（UNION ALL）：現役社員と退職社員のリストを一つにまとめる**

```sql
-- 現役社員のリスト
SELECT id, name, '現役' AS status FROM employees WHERE retirement_date IS NULL
UNION ALL
-- 退職社員のリスト
SELECT id, name, '退職' AS status FROM retired_employees;
```

**例（EXCEPT）：営業部にはいるが、特定のプロジェクト（`project_A_members`）には参加していない社員を探す**

```sql
-- 営業部の社員IDリスト
SELECT employee_id FROM employees WHERE department_id = 1
EXCEPT
-- プロジェクトAのメンバーIDリスト
SELECT employee_id FROM project_A_members;
```

#### 8-4. 共通テーブル式 (CTE: Common Table Expressions)

CTEは、`WITH`句を使って、複雑なクエリの**一部を名前付きの一時的な結果セットとして定義**する機能です。サブクエリ（特に`FROM`句のインラインビュー）を多用するとクエリが入れ子構造になり読みにくくなりますが、CTEを使うことでクエリをフラットに、かつ部品ごとに分割して記述できるため、**可読性とメンテナンス性が大幅に向上**します。

**構文:**
```sql
WITH
  cte_name1 AS (
    -- SELECT文1
  ),
  cte_name2 AS (
    -- SELECT文2 (cte_name1を利用可能)
  )
SELECT ...
FROM cte_name1
JOIN cte_name2 ON ...;
```

**例：インラインビューの例をCTEで書き換える**

先ほどの「部署ごとの情報と社員情報をJOINする」クエリをCTEで書き直してみます。

```sql
WITH department_summary AS (
    -- CTE 1: 部署ごとのサマリー情報を計算
    SELECT
        d.id,
        d.name AS department_name,
        AVG(e.salary) AS avg_salary
    FROM
        departments d
    JOIN
        employees e ON d.id = e.department_id
    GROUP BY
        d.id, d.name
)
-- メインクエリ
SELECT
    ds.department_name,
    AVG(e.age) AS avg_age,
    ds.avg_salary
FROM
    employees AS e
JOIN
    department_summary AS ds ON e.department_id = ds.id
GROUP BY
    ds.department_name, ds.avg_salary;
```
`WITH`句で先に`department_summary`という部品を定義しておくことで、メインクエリが非常にすっきりと読みやすくなっているのが分かります。複雑なクエリを書く際には、積極的にCTEを活用することが推奨されます。

### 第9章: 【応用】トランザクションと同時実行制御

データベースの信頼性を支える中心的な概念が「トランザクション」です。特に、データの更新が伴うシステムでは必須の知識となります。

#### 9-1. トランザクションとは？

トランザクションとは、**関連する一連の処理を一つの論理的な作業単位としてまとめたもの**です。この一連の処理は「すべて成功する」か「すべて失敗する」かのどちらかでなければならず、中途半端な状態で終わることは許されません。これを**「不可分性」または「原子性」**と言います。

**銀行の振込処理の例:**
Aさんの口座からBさんの口座へ1万円を振り込む処理は、以下の2つの更新処理から成ります。

1.  Aさんの口座残高から1万円を引く (`UPDATE`)
2.  Bさんの口座残高に1万円を足す (`UPDATE`)

もし1の処理は成功したのに、2の処理の直前にシステムがダウンしてしまったらどうなるでしょうか？Aさんの口座から1万円が消えたのに、Bさんの口座には入金されず、1万円が宙に浮いてしまいます。これはデータの不整合であり、絶対にあってはならない事態です。

トランザクションは、この2つの処理を一つの塊として扱い、**両方が成功した場合にのみ結果をデータベースに確定（コミット）**し、**途中で何か問題が起きた場合はすべての処理を無かったことにする（ロールバック）**仕組みを提供します。

#### 9-2. ACID特性

トランザクションが保証すべき4つの重要な性質は、頭文字を取って**ACID特性**と呼ばれます。

1.  **Atomicity (原子性)**: トランザクションに含まれる処理は、すべて実行されるか、まったく実行されないかのどちらかであることが保証される。
2.  **Consistency (一貫性/整合性)**: トランザクションの前後で、データベースの整合性（データに矛盾がない状態）が保たれる。
3.  **Isolation (独立性/隔離性)**: 複数のトランザクションを同時に実行しても、それぞれのトランザクションは互いに干渉せず、あたかも一つずつ順番に実行されているかのように見えることが保証される。
4.  **Durability (永続性)**: 一度コミットされたトランザクションの結果は、その後システムに障害が発生しても失われないことが保証される。

#### 9-3. トランザクション制御言語 (TCL)

これらのトランザクションをSQLで制御するための命令がTCLです。

*   **`START TRANSACTION` (または `BEGIN`)**: トランザクションの開始を宣言します。
*   **`COMMIT`**: トランザクション内のすべての処理を成功とみなし、変更をデータベースに恒久的に反映（確定）します。
*   **`ROLLBACK`**: トランザクション内でエラーが発生した場合や、処理を取り消したい場合に、トランザクション開始前の状態にデータベースを戻します。
*   **`SAVEPOINT`**: トランザクションの途中に「セーブポイント」という中間地点を設定します。`ROLLBACK`時にトランザクション全体の開始点ではなく、指定したセーブポイントまで戻ることができます。

**TCLの利用例:**

```sql
START TRANSACTION;

-- 処理1: Aさんの口座から1万円引く
UPDATE accounts SET balance = balance - 10000 WHERE user_id = 'A';

-- 処理2: Bさんの口座に1万円足す
UPDATE accounts SET balance = balance + 10000 WHERE user_id = 'B';

-- ここで何らかのチェックを行い、問題なければCOMMIT、問題があればROLLBACKする
-- 例えば、Aさんの残高がマイナスになっていないか等を確認

-- 全ての処理が成功したので、変更を確定
COMMIT;

-- もし途中でエラーが起きた場合
-- ROLLBACK;
```
多くのデータベースでは、`UPDATE`や`INSERT`などのDML文は、デフォルトで「自動コミット」モード（1文ごとに自動でコミットされる）になっています。複数の処理を一つのトランザクションとして扱いたい場合は、明示的に`START TRANSACTION`を宣言する必要があります。

#### 9-4. ロックと分離レベル

複数のユーザーが同時にデータベースにアクセスする環境では、**同時実行制御**が重要になります。もし何の制御もなければ、以下のような問題が発生する可能性があります。

*   **ダーティリード**: あるトランザクションが更新中の、まだコミットされていないデータを、別のトランザクションが読み込んでしまう問題。
*   **ノンリピータブルリード（ファジーリード）**: あるトランザクションが同じ行を複数回読み込む間に、別のトランザクションがその行を更新・コミットしたため、読み込むたびに結果が変わってしまう問題。
*   **ファントムリード**: あるトランザクションが特定の範囲を検索した後、別のトランザクションがその範囲に新しい行を挿入・コミットしたため、再度同じ範囲を検索すると以前はなかった行（ファントム＝幽霊）が見えてしまう問題。

これらの問題を解決するために、データベースは**ロック**という仕組みを使います。あるトランザクションがデータを更新している間、そのデータにロックをかけることで、他のトランザクションからのアクセスを制限します。

どのレベルまで同時実行の問題を許容するかを設定するのが**トランザクション分離レベル（Isolation Level）**です。分離レベルを高くするほどデータの整合性は強固になりますが、ロックの範囲が広がり、システムの並列性（パフォーマンス）は低下するトレードオフの関係にあります。代表的な分離レベルには `READ COMMITTED` や `REPEATABLE READ` などがあります。

### 第10章: パフォーマンスチューニング入門

SQLは非常に強力ですが、書き方によっては非常に遅くなることがあります。特にデータ量が増えるにつれて、パフォーマンスの問題は顕著になります。ここでは、SQLのパフォーマンスを改善するための基本的なアプローチを紹介します。

#### 10-1. なぜSQLは遅くなるのか？

SQLが遅くなる主な原因は以下の通りです。

*   **フルテーブルスキャン**: `WHERE`句の条件に合う行を探すために、テーブルの先頭から末尾まで全行をスキャンすること。データ量が多いテーブルでは致命的に遅くなります。
*   **不適切なインデックス**: 検索を高速化する「インデックス」が設定されていない、またはうまく使われていない。
*   **非効率なJOIN**: 巨大なテーブル同士を不必要にJOINしている。
*   **非効率なサブクエリ**: 特に相関サブクエリが原因で、行ごとに重い処理が走っている。

#### 10-2. インデックス (Index)

**インデックスは、データベースにおける「本の索引」**のようなものです。特定のデータがテーブルのどこにあるかを高速に見つけ出すための仕組みです。

`WHERE`句や`JOIN`の`ON`句で頻繁に使用されるカラムにインデックスを作成しておくと、データベースはフルテーブルスキャンをせず、インデックスを使って目的の行の場所を直接特定できるため、検索速度が劇的に向上します。

**インデックスの作成:**
`CREATE INDEX インデックス名 ON テーブル名 (カラム名1, カラム名2, ...);`

**例：`employees`テーブルの`department_id`カラムにインデックスを作成する**

```sql
CREATE INDEX idx_employees_department_id ON employees (department_id);
```
これにより、`WHERE department_id = ...` という条件での検索が高速化されます。

**■インデックスのメリットとデメリット**

*   **メリット**:
    *   `SELECT`文の検索速度が大幅に向上する（特に`WHERE`句、`JOIN`句、`ORDER BY`句）。

*   **デメリット**:
    *   **更新性能の低下**: `INSERT`, `UPDATE`, `DELETE` を行うたびに、テーブルのデータだけでなくインデックスも更新する必要があるため、これらの処理は遅くなる。
    *   **ストレージの消費**: インデックスはテーブル本体とは別にデータを保持するため、その分のディスク容量が必要になる。

したがって、インデックスは無闇に作成するのではなく、**検索頻度と更新頻度のバランスを考えて、効果的なカラムにのみ作成する**ことが重要です。一般的には、主キー、外部キー、`WHERE`句で頻繁に指定されるカラムなどが候補となります。

#### 10-3. 実行計画 (Execution Plan)

実行計画とは、**データベースが特定のSQLを、内部的にどのような手順で実行するかを示した計画書**のことです。SQLのパフォーマンスチューニングは、まずこの実行計画を読み解くことから始まります。

ほとんどのDBMSには、実行計画を確認するためのコマンドが用意されています。

**構文:**
`EXPLAIN SQL文;`

**例：**
`EXPLAIN SELECT * FROM employees WHERE department_id = 1;`

`EXPLAIN`を実行すると、このクエリがインデックスを使って高速に検索（Index Scan）しているのか、それともテーブルを全件スキャン（Full Table Scan / Seq Scan）しているのかなどが分かります。もし遅いクエリで「Full Table Scan」が表示されたら、それはインデックスが効いていない証拠であり、インデックスの作成やクエリの見直しを検討する手がかりとなります。

#### 10-4. SQLチューニングのヒント

*   **`SELECT *` を避ける**: 常に必要なカラムだけを明示的に指定しましょう。不要なデータを取得しないことで、ネットワーク転送量やメモリ使用量を削減できます。また、「カバリングインデックス」という特定のインデックスだけでクエリが完結するテクニックが使える可能性も高まります。
*   **`WHERE`句の左辺を加工しない**: `WHERE SUBSTRING(name, 1, 2) = '田中'` や `WHERE age + 1 = 30` のように、`WHERE`句の条件指定でカラム側に関数や計算を適用すると、多くの場合インデックスが使われなくなります。`WHERE name LIKE '田中%'` や `WHERE age = 29` のように、カラムはそのままの形で条件式を書くように心がけましょう。
*   **`IN`より`EXISTS`や`JOIN`を検討する**: サブクエリで`IN`を使うと、サブクエリの結果セットが大きい場合に非効率になることがあります。同じ処理を`EXISTS`や`JOIN`で書き換えられないか検討しましょう。どちらが速いかはデータ分布やDBMSによりますが、試してみる価値はあります。
*   **`OR`を`UNION ALL`で書き換える**: `WHERE col1 = 'A' OR col2 = 'B'` のような条件は、インデックスが利用しにくい場合があります。`col1`と`col2`にそれぞれインデックスがある場合、`UNION ALL`を使って2つのクエリに分割することで、両方のインデックスが使われて速くなることがあります。
*   **実行計画を信じる**: 最終的にどの方法が速いかは、データや環境に依存します。憶測でチューニングするのではなく、必ず`EXPLAIN`で実行計画を確認し、実際の実行時間を計測して、改善されたかを客観的に判断することが重要です。

### 第11章: データベースごとの方言 (Dialects)

SQLにはANSI/ISOによる標準規格がありますが、各DBMS（MySQL, PostgreSQL, Oracleなど）は標準機能に加えて、独自の拡張機能や構文を持っています。これをSQLの**方言（Dialect）**と呼びます。

#### 11-1. なぜ方言が存在するのか？

*   歴史的な経緯で、標準化される前から各社が独自に機能を実装してきたため。
*   標準にはない便利な機能や、特定の用途に特化した高性能な機能を提供するため。

この方言の存在により、あるDBMSで動いたSQLが、別のDBMSではエラーになることがあります。開発や学習の際には、自分が使っているDBMSのドキュメントを確認する習慣が大切です。

#### 11-2. 代表的な方言の例

| 機能 | MySQL | PostgreSQL | SQL Server | Oracle | 標準SQL |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **文字列連結** | `CONCAT(str1, str2)` | `str1 \|\| str2` | `str1 + str2` | `str1 \|\| str2` | `str1 \|\| str2` |
| **現在時刻取得** | `NOW()` | `NOW()`, `CURRENT_TIMESTAMP` | `GETDATE()` | `SYSDATE` | `CURRENT_TIMESTAMP` |
| **件数制限** | `LIMIT n` | `LIMIT n` | `TOP n` | `FETCH FIRST n ROWS ONLY` | `FETCH FIRST n ROWS ONLY` |
| **自動連番** | `AUTO_INCREMENT` | `SERIAL`, `IDENTITY` | `IDENTITY` | `SEQUENCE` + `TRIGGER` | `GENERATED AS IDENTITY` |
| **NULLの扱い** | `IFNULL(col, val)` | `COALESCE(col, val)` | `ISNULL(col, val)` | `NVL(col, val)` | `COALESCE(col, val)` |

`COALESCE`は多くのDBMSでサポートされている標準的な関数で、引数を複数取り、最初に見つかったNULLでない値を返すため、方言を避ける際に便利です。

#### 11-3. 方言への対処法

*   **使用するDBMSを意識する**: 自分がどのDBMSを使っているかを常に意識し、そのDBMSの公式ドキュメントを参照する癖をつけましょう。
*   **標準SQLを心がける**: 可能な限り標準SQLの構文で書くようにすれば、将来的にデータベースを移行する際のリスクを低減できます。
*   **ORMを利用する**: アプリケーション開発では、ORM（Object-Relational Mapping）ライブラリを使うことも多いです。ORMはプログラムコード（Java, Python, Rubyなど）からデータベースを操作するためのもので、内部で各DBMSの方言を吸収し、開発者が方言を意識せずに済むようにしてくれる場合があります。

